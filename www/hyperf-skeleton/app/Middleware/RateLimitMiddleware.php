<?php

declare(strict_types=1); // 严格类型声明，确保代码中的类型安全

namespace App\Middleware; // 命名空间声明，表示该类属于App\Middleware

use App\Log; // 引入日志类
use Hyperf\Contract\ConfigInterface; // 引入Hyperf配置接口
use Hyperf\HttpMessage\Stream\SwooleStream; // 引入Hyperf的Swoole流处理类
use Hyperf\HttpServer\Contract\RequestInterface; // 引入Hyperf的请求接口
use Hyperf\HttpServer\Contract\ResponseInterface as HttpResponse; // 引入Hyperf的响应接口，并别名为HttpResponse
use Hyperf\Redis\Redis; // 引入Hyperf的Redis类
use Psr\Container\ContainerInterface; // 引入PSR容器接口
use Psr\Http\Message\ResponseInterface; // 引入PSR响应接口
use Psr\Http\Message\ServerRequestInterface; // 引入PSR服务器请求接口
use Psr\Http\Server\MiddlewareInterface; // 引入PSR中间件接口
use Psr\Http\Server\RequestHandlerInterface; // 引入PSR请求处理接口

class RateLimitMiddleware implements MiddlewareInterface // 定义RateLimitMiddleware类，实现MiddlewareInterface接口
{
    /**
     * @var ContainerInterface
     */
    protected $container; // 容器接口实例

    /**
     * @var RequestInterface
     */
    protected $request; // 请求接口实例

    /**
     * @var HttpResponse
     */
    protected $response; // 响应接口实例

    /**
     * @var ConfigInterface
     */
    protected $config; // 配置接口实例

    /**
     * @var Redis
     */
    protected $redis; // Redis实例

    public function __construct(
        ContainerInterface $container,
        HttpResponse $response,
        RequestInterface $request,
        ConfigInterface $config,
        Redis $redis
    ) {
        $this->container = $container; // 初始化容器实例
        $this->response  = $response;  // 初始化响应实例
        $this->request   = $request;   // 初始化请求实例
        $this->config    = $config;    // 初始化配置实例
        $this->redis     = $redis;     // 初始化Redis实例
    }
    /**
     * 处理请求并应用速率限制
     *
     * 该方法拦截 incoming 请求，检查是否需要应用速率限制如果请求的操作需要限流，
     * 则检查用户是否超过了允许的请求次数如果用户超过了限制，则返回错误响应；
     * 否则，请求将被处理
     *
     * @param ServerRequestInterface $request The incoming server request
     * @param RequestHandlerInterface $handler The request handler to use for processing the request
     *
     * @return ResponseInterface The response generated by processing the request
     */
    public function process(ServerRequestInterface $request, RequestHandlerInterface $handler): ResponseInterface
    {
        $uri    = $this->request->getUri()->getPath(); // 获取当前请求的URI路径
        $userId = $this->request->input('user_id'); // 获取请求中的用户ID

        // 获取限流配置
        $rateLimitConfig = $this->config->get('rate_limit', []); // 从配置中获取限流设置，默认为空数组

        // 根据路径判断是哪种操作
        $action = '';
        if (strpos($uri, '/api/red-packet/create') !== false) {
            $action = 'create'; // 如果路径包含'/api/red-packet/create'，则操作为'create'
        } elseif (strpos($uri, '/api/red-packet/grab') !== false) {
            $action = 'grab'; // 如果路径包含'/api/red-packet/grab'，则操作为'grab'
        }

        // 如果是需要限流的操作
        if ($action && isset($rateLimitConfig[$action]) && $userId) {
            // 记录进入限流检查的日志
            Log::debug(sprintf('用户[%s]请求[%s]操作，开始限流检查', $userId, $action));

            $config   = $rateLimitConfig[$action]; // 获取具体操作的限流配置
            $capacity = $config['capacity'] ?? 10; // 默认容量为10
            $seconds  = $config['seconds'] ?? 60;   // 默认时间窗口为60秒

            // 构建Redis键
            $key = "rate_limit:{$action}:{$userId}:" . intval(time() / $seconds);

            // 获取当前计数
            $current = (int) $this->redis->get($key);

            // 记录当前请求计数情况
            Log::info(sprintf(
                '用户[%s]在[%s]操作中的请求计数: %d/%d',
                $userId,
                $action,
                $current,
                $capacity
            ));

            // 如果超过限制
            if ($current >= $capacity) {
                // 记录限流警告日志
                Log::warning(sprintf(
                    '用户[%s]在[%s]操作中触发限流，当前请求计数: %d/%d',
                    $userId,
                    $action,
                    $current,
                    $capacity
                ));

                return $this->response->json([
                    'code'    => 429,
                    'message' => '请求过于频繁，请稍后再试',
                    'data'    => null,
                ])->withStatus(429); // 返回状态码429和错误信息
            }

            // 检查是否接近限流阈值（达到80%）
            if ($current >= $capacity * 0.8) {
                Log::info(sprintf(
                    '用户[%s]在[%s]操作中接近限流阈值，当前请求计数: %d/%d',
                    $userId,
                    $action,
                    $current,
                    $capacity
                ));
            }

            // 增加计数并设置过期时间
            $this->redis->incr($key);
            $this->redis->expire($key, $seconds);

            // 记录增加后的计数
            $newCount = $current + 1;
            Log::debug(sprintf(
                '用户[%s]在[%s]操作中的请求计数已更新: %d/%d',
                $userId,
                $action,
                $newCount,
                $capacity
            ));
        }

        return $handler->handle($request); // 继续处理请求
    }
}